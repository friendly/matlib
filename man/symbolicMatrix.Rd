% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/symbolicMatrix.R
\name{symbolicMatrix}
\alias{symbolicMatrix}
\alias{getLatex}
\alias{getLatex.symbolicMatrix}
\alias{getBody}
\alias{getBody.symbolicMatrix}
\alias{getWrapper}
\alias{getWrapper.symbolicMatrix}
\alias{Dim}
\alias{Dim.symbolicMatrix}
\alias{Nrow}
\alias{Nrow.symbolicMatrix}
\alias{Ncol}
\alias{Ncol.symbolicMatrix}
\alias{print.symbolicMatrix}
\alias{+.symbolicMatrix}
\alias{-.symbolicMatrix}
\alias{\%*\%.symbolicMatrix}
\alias{*.symbolicMatrix}
\alias{t.symbolicMatrix}
\alias{determinant.symbolicMatrix}
\alias{solve.symbolicMatrix}
\alias{as.double.symbolicMatrix}
\title{Create a Symbolic Matrix for LaTeX}
\usage{
symbolicMatrix(
  symbol = "x",
  nrow = "n",
  ncol = "m",
  matrix = "pmatrix",
  diag = FALSE,
  sparse = FALSE,
  zero.based = c(FALSE, FALSE),
  end.at = c("n - 1", "m - 1"),
  comma = any(zero.based),
  exponent,
  transpose = FALSE,
  show.size = FALSE,
  digits = getOption("digits") - 2,
  fractions = FALSE,
  prefix = "",
  suffix = "",
  lhs
)

getLatex(x, ...)

\method{getLatex}{symbolicMatrix}(x, ...)

getBody(x, ...)

\method{getBody}{symbolicMatrix}(x, ...)

getWrapper(x, ...)

\method{getWrapper}{symbolicMatrix}(x, ...)

Dim(x, ...)

\method{Dim}{symbolicMatrix}(x, ...)

Nrow(x, ...)

\method{Nrow}{symbolicMatrix}(x, ...)

Ncol(x, ...)

\method{Ncol}{symbolicMatrix}(x, ...)

\method{print}{symbolicMatrix}(x, onConsole = TRUE, ...)

\method{+}{symbolicMatrix}(e1, e2)

\method{-}{symbolicMatrix}(e1, e2)

\method{\%*\%}{symbolicMatrix}(x, y)

\method{*}{symbolicMatrix}(e1, e2)

\method{t}{symbolicMatrix}(x)

\method{determinant}{symbolicMatrix}(x, logarithm, ...)

\method{solve}{symbolicMatrix}(
  a,
  b,
  simplify = FALSE,
  frac = c("\\\\dfrac", "\\\\frac", "\\\\tfrac", "\\\\cfrac"),
  ...
)

\method{as.double}{symbolicMatrix}(x, locals = list(), ...)
}
\arguments{
\item{symbol}{name for matrix elements, character string. For LaTeX symbols,
the backslash must be doubled because it is an escape character in R.
That is, you must use  \code{symbol = "\\\\beta"} to get \eqn{\beta}. Alternatively, this can be an
R matrix object, containing LaTeX code for the elements. For a row or column vector, use
\code{matrix(..., nrow=1)} or \code{matrix(..., ncol=1)}}

\item{nrow}{Number of rows, a single character representing rows symbolically, or an integer, generating
that many rows.}

\item{ncol}{Number of columns, a single character representing columns symbolically, or an integer, generating
that many columns.}

\item{matrix}{Character string giving the LaTeX matrix environment used in \code{\\begin{}}, \code{\\end{}}. Typically one of:
\describe{
   \item{\code{"pmatrix"}}{uses parentheses: \code{"(", ")"}}
   \item{\code{"bmatrix"}}{uses square brackets: \code{"[", "]"}}
   \item{\code{"Bmatrix"}}{uses braces: \code{"{", "}"}}
   \item{\code{"vmatrix"}}{uses vertical bars: \code{"|", "|"}}
   \item{\code{"Vmatrix"}}{uses double vertical bars: \code{"||", "||"}}
   \item{\code{"matrix"}}{generates a plain matrix without delimeters}
}}

\item{diag}{logical; if \code{TRUE}, off-diagonal elements are all 0 (and \code{nrow} must == \code{ncol})}

\item{sparse}{logical; if \code{TRUE} replace 0's with empty characters to print a sparse matrix}

\item{zero.based}{logical 2-vector; start the row and/or column indices at 0 rather than 1;
the default is \code{c(FALSE, FALSE)}; applies only if \code{nrow} is character-valued}

\item{end.at}{if row or column indices start at 0, should they end at \code{n - 1} and
\code{m - 1} or at \code{n} and \code{m}? (where \code{n} and \code{m} represent the
characters used to denote the number of rows and columns, respectively);
the default is \code{c("n - 1", "m - 1")}}

\item{comma}{logical; if \code{TRUE}, commas are inserted between row and column subscripts, as in
\code{x_{1,1}}; the default is \code{FALSE} except for zero-based indices.}

\item{exponent}{if specified, e.g., \code{"-1"}, or \code{"1/2"},  the exponent is applied to the matrix}

\item{transpose}{if \code{TRUE}, the transpose symbol \code{"\\top"} is appended to the matrix; this may
also be a character string, e.g., \code{"T"}, \code{"\\prime"}, \code{"\textsf{T}"} are
commonly used.}

\item{show.size}{logical; if \code{TRUE} shows the order of the matrix as an appended subscript.}

\item{digits}{for a numeric matrix, number of digits to display;}

\item{fractions}{logical; if \code{TRUE}, try to express non-integers as rational numbers, using the \code{\link[MASS]{fractions}}
function.}

\item{prefix}{optional character string to be pre-pended to each matrix element, e.g, to wrap each
element in a function like \code{"\\sqrt"} (but add braces)}

\item{suffix}{optional character string to be appended to each matrix element, e.g., for exponents
on each element}

\item{lhs}{character; an optional LaTeX expression, e.g, "\code{\\boldsymbol{\\Lamda}}", for left-hand
side of an equation
with the generated matrix on the right-hand side.}

\item{x}{a \code{"symbolicMatrix"} object}

\item{...}{for compatibility with the \code{print()} generic function, ignored}

\item{onConsole}{if \code{TRUE}, the default, print the LaTeX code for
the matrix on the R console.}

\item{e1}{a \code{"symbolicMatrix"} object (or, for \code{*} a scalar).}

\item{e2}{a \code{"symbolicMatrix"} object (or, for \code{*} a scalar).}

\item{y}{a \code{"symbolicMatrix"} object}

\item{logarithm}{ignored; to match the \code{\link{determinant}} generic}

\item{a}{a \code{"symbolicMatrix"} object representing a square matrix}

\item{b}{ignored; to match the \code{\link{solve}} generic}

\item{simplify}{if \code{TRUE} (the default is \code{FALSE}),
return a LaTeX expression with the inverse of the determinant in
front of the adjoint matrix rather than a \code{"symbolicMatrix"} object in which each
element of the adjoint matrix is divided by the determinant.}

\item{frac}{LaTeX command to use in forming fractions; the default
is \code{"\\dfrac"}}

\item{locals}{an optional list of variables to be given
specific numeric values; e.g., 
\code{locals = list(a = 1, b = 5, c = -1, d = 4)}}
}
\value{
\code{symbolicMatrix()} returns an object of class \code{"symbolicMatrix"}
         which contains the LaTeX representation of the matrix as a character string,
         along with some other information. The slots
         in the returned object are named \code{"matrix"} (the LaTeX representation of the
         matrix); \code{"dim"} (\code{nrow} and \code{ncol}); \code{"body"} (a character
         matrix of LaTeX expressions for the cells of the matrix);
         \code{"wrapper"}(the beginning and ending lines for the
         LaTeX matrix environment).
}
\description{
Constructs the LaTeX code for a symbolic matrix, whose elements are a \code{symbol}, with row and column subscripts.
For example:
\preformatted{
 \\begin{pmatrix}
   x_{11}  & x_{12}  & \\dots  & x_{1m}  \\
   x_{21}  & x_{22}  & \\dots  & x_{2m}  \\
   \\vdots & \\vdots & \\ddots & \\vdots \\
   x_{n1}  & x_{n2}  & \\dots  & x_{nm}
 \\end{pmatrix}
 }

 When rendered in LaTeX, this produces:
 \deqn{
 \begin{pmatrix}
   x_{11} & x_{12} & \cdots & x_{1m} \\
   x_{21} & x_{22} & \cdots & x_{2m} \\
   \vdots & \vdots &        & \vdots \\
   x_{n1} & x_{n2} & \cdots & x_{nm} \\
 \end{pmatrix}
 }

% \figure{man/figures/symbMat-x.png}{options: width=150 alt="LaTeX result for the symbolic n x m matrix"}.

Alternatively, instead of characters,
the number of rows and/or columns can be \bold{integers}, generating a matrix of given size.

As well, instead of a character for the matrix \code{symbol}, you can supply a \bold{matrix} of arbitrary character
strings (in LaTeX notation), and these will be used as the elements of the matrix.

You can print the resulting LaTeX code to the console. When the result is assigned to a variable,
you can send it to the clipboard using \code{\link[clipr]{write_clip}}. Perhaps most convenient of all,
the function can be used used in a markdown chunk in a \code{Rmd} or \code{qmd} document, e.g,

\preformatted{
```{r results = "asis"}
symbolicMatrix("\\lambda", nrow=2, ncol=2,
               diag=TRUE,
               lhs = "\\boldsymbol{\\Lambda}")
```
}

This generates
\deqn{
 \boldsymbol{\Lambda} = \begin{pmatrix}
 \lambda_{1} & 0           \\
 0           & \lambda_{2} \\
 \end{pmatrix}
 }
}
\details{
This implementation assumes that the LaTeX \code{amsmath} package will be available because it uses the shorthands
\code{\\begin{pmatrix}}, ... rather than
\preformatted{
\\left(
  \\begin{array}(ccc)
  ...
  \\end{array}
\\right)
}.

You may need to use \code{extra_dependencies: ["amsmath"]} in your YAML header of a \code{Rmd} or \code{qmd} file.

You can actually supply a numeric matrix as the \code{symbol}, but the result will not be pretty
unless the elements are integers or are rounded. For a LaTeX representation of general numeric matrices, use
\code{\link{matrix2latex}}.

The accessor functions \code{getLatex()}, \code{getBody()}, \code{getWrapper()},
\code{getDim()}, \code{getNrow()}, and \code{getNcol()} may be used to retrieve
components of the returned object.

There are \code{"symbolicMatrix"} methods for several standard R arithmetic
operators and function, including \code{+} (matrix addition), \code{-} 
(matrix subtraction), \code{*} (product of a scalar and a matrix),
\code{\%*\%} (matrix product), \code{t()} (transpose), \code{determinant()}, 
\code{solve()} (matrix inverse),  and 
\code{as.double()} (coercion to numeric, if possible).
These operators and functions only apply to \code{"symbolicMatrix"} objects
of definite (i.e., numeric) dimensions.
}
\examples{
symbolicMatrix()

# return value
mat <- symbolicMatrix()
str(mat)
cat(getLatex(mat))
# copy to clipboard
#clipr::write_clip(mat)  # this can't be done in non-interactive mode

# can use a complex symbol
symbolicMatrix("\\\\widehat{\\\\beta}", 2, 4)

# numeric rows/cols
symbolicMatrix(ncol=3)
symbolicMatrix(nrow=4)
symbolicMatrix(nrow=4, ncol=4)

# diagonal matrices
symbolicMatrix(nrow=3, ncol=3, diag=TRUE)
symbolicMatrix(nrow="n", ncol="n", diag=TRUE)
symbolicMatrix(nrow="n", ncol="n", diag=TRUE, sparse=TRUE)

# commas, exponents, transpose
symbolicMatrix("\\\\beta", comma=TRUE, exponent="-1")
symbolicMatrix("\\\\beta", comma=TRUE, transpose=TRUE)
symbolicMatrix("\\\\beta", comma=TRUE, exponent="-1", transpose=TRUE)

# for a row/column vector, wrap in matrix()
symbolicMatrix(matrix(LETTERS[1:4], nrow=1))
symbolicMatrix(matrix(LETTERS[1:4], ncol=1))

# represent the SVD, X = U D V'  symbolically
X <- symbolicMatrix("x", "n", "p")
U <- symbolicMatrix("u", "n", "k")
D <- symbolicMatrix("\\\\lambda", "k", "k", diag=TRUE)
V <- symbolicMatrix("v", "k", "p", transpose = TRUE)
cat("\\\\mathrm{SVD:}\n", getLatex(X), "=\n", getLatex(U),
    getLatex(D), getLatex(V))

# specify left hand side
symbolicMatrix("\\\\lambda", 3, 3, diag=TRUE, lhs = "\\\\boldsymbol{\\\\Lambda}")
symbolicMatrix("\\\\lambda", 3, 3, diag=TRUE, sparse=TRUE,
  lhs = "\\\\boldsymbol{\\\\Lambda}")

# supply a matrix for 'symbol'
m <- matrix(c(
  "\\\\alpha", "\\\\beta",
  "\\\\gamma", "\\\\delta",
  "\\\\epsilon", "\\\\pi",
  0 , 0), 4, 2, byrow=TRUE)
symbolicMatrix(m)

# Identity matrix
symbolicMatrix(diag(3), lhs = "\\\\mathbf{I}_3")
symbolicMatrix(diag(3), lhs = "\\\\mathbf{I}_3", sparse=TRUE)

# prefix / suffix
symbolicMatrix(prefix="\\\\sqrt{", suffix="}")
symbolicMatrix(suffix="^{1/2}")

# show size (order) of a matrix
symbolicMatrix(show.size=TRUE)
symbolicMatrix(nrow=3, ncol=4, show.size=TRUE)

# handling fractions
m <- matrix(3/(1:9), 3, 3)
symbolicMatrix(m)
symbolicMatrix(m, digits=2)
symbolicMatrix(m, fractions=TRUE)

# zero-based indexing
symbolicMatrix(zero.based=c(TRUE, TRUE))

A <- symbolicMatrix(symbol="a", nrow=2, ncol=2)
B <- symbolicMatrix(symbol="b", nrow=2, ncol=2)
A
B
A + B
A - B
"a" * A
C <- symbolicMatrix(symbol="c", nrow=2, ncol=3)
A \%*\% C
t(C)
determinant(A)
cat(solve(A, simplify=TRUE))
D <- symbolicMatrix(matrix(letters[1:4], 2, 2))
D
as.numeric(D, locals=list(a=1, b=2, c=3, d=4))
X <- symbolicMatrix(matrix(c(3, 2, 0, 1, 1, 1, 2,-2, 1), 3, 3))
X
as.numeric(X)
MASS::fractions(as.numeric(solve(X)))
(d <- determinant(X))
eval(parse(text=(gsub("\\\\\\\\cdot", "*", d))))
}
\seealso{
\code{\link{matrix2latex}}, \code{\link[clipr]{write_clip}}
}
\author{
John Fox
}
