% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Eigen.R
\name{SVD}
\alias{SVD}
\title{Singular Value Decomposition of a Matrix}
\usage{
SVD(
  X,
  method = c("Jacobi", "eigen"),
  tol = sqrt(.Machine$double.eps),
  max.iter = 100
)
}
\arguments{
\item{X}{a square symmetric matrix}

\item{method}{either \code{"Jacobi"} (the default) or \code{"eigen"}}

\item{tol}{zero and convergence tolerance}

\item{max.iter}{maximum number of iterations}
}
\value{
a list of three elements: \code{d}-- singular values, \code{U}-- left singular vectors, \code{V}-- right singular vectors
}
\description{
Compute the singular-value decomposition of a matrix \eqn{X} either by Jacobi
rotations (the default) or from the eigenstructure of \eqn{X'X} using
\code{\link{Eigen}}. Both methods are iterative.
The result consists of two orthonormal matrices, \eqn{U}, and \eqn{V} and the vector \eqn{d}
of singular values, such that \eqn{X = U diag(d) V'}.
}
\details{
The default method is more numerically stable, but the eigenstructure method
is much simpler.
Singular values of zero are not retained in the solution.
}
\examples{
C <- matrix(c(1,2,3,2,5,6,3,6,10), 3, 3) # nonsingular, symmetric
C
SVD(C)

# least squares by the SVD
data("workers")
X <- cbind(1, as.matrix(workers[, c("Experience", "Skill")]))
head(X)
y <- workers$Income
head(y)
(svd <- SVD(X))
VdU <- svd$V \%*\% diag(1/svd$d) \%*\%t(svd$U)
(b <- VdU \%*\% y)
coef(lm(Income ~ Experience + Skill, data=workers))
}
\seealso{
\code{\link[base]{svd}}, the standard svd function

\code{\link{Eigen}}
}
\author{
John Fox and Georges Monette
}
